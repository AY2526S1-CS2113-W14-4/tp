@startuml
' Model Component Sequence Diagram
' Shows interactions between Logic, Model, InternshipList, Internship, Date and Status
' Additional abstract components: Logic (parses commands) and Storage (persists data)
'
actor User as "User"
participant UI as "UI (User Interface)"
participant CommandParser as "CommandParser (parses commands)"
participant Model as "Model (InternityManager)"

box Model
participant InternshipList as "<<class>>\nInternshipList"
participant Internship as "Internship"
participant Date as "Date"
participant Status as "<<enum>>\nStatus"
endbox

participant Storage as "<<class>>\nStorage"

' --- Scenario 1: Adding a new internship ---
== Adding a new internship ==
' User types an `add` command; UI receives user input and forwards to CommandParser, which hands off a semantic request to Model
User -> UI: `add company/COMP role/ROLE deadline/DD-MM-YYYY pay/AMOUNT`
UI -> CommandParser: parseInput(input)
CommandParser -> Model: addInternship(company, role, deadlineStr, pay)
' Model validates high-level constraints then delegates to the list component
Model -> InternshipList: add(company, role, deadlineStr, pay)
' InternshipList constructs a new Internship object (calls constructor)
InternshipList -> Internship: new(company, role, deadlineStr, pay)
' Internship object parses and stores a Date and Status internally
Internship -> Date: parse(deadlineStr) : Date
Internship -> Status: initDefault() : Status (Pending)
' Construction returns the Internship instance to InternshipList
Internship --> InternshipList: Internship
' InternshipList appends to internal collection
InternshipList -> InternshipList: addToCollection(Internship)
' After mutation, Model requests Storage to persist the updated list
InternshipList -> Storage: save(internships.txt, currentState)
Storage --> InternshipList: success
Model <-- InternshipList: addedConfirmation
CommandParser <-- Model: successMessage("Added: COMPANY - ROLE")
UI <-- CommandParser: display(successMessage)
User <-- UI: display(successMessage)

' --- Scenario 2: Updating status of an existing internship ---
== Updating status of an existing internship ==
User -> UI: `update 3 status/Interviewing`
UI -> CommandParser: parseInput(input)
CommandParser -> Model: updateStatus(index=3, newStatus="Interviewing")
Model -> InternshipList: get(index=3)
InternshipList --> Model: Internship@3
Model -> Internship: setStatus("Interviewing")
Internship -> Status: update("Interviewing")
Internship --> Model: updatedInternship
Model -> InternshipList: replace(index=3, updatedInternship)
' Persist change
InternshipList -> Storage: save(internships.txt, currentState)
Storage --> InternshipList: success
CommandParser <-- Model: successMessage("Updated status")
UI <-- CommandParser: display(successMessage)
UI --> User: display(successMessage)

' --- Scenario 3: Querying nearest deadline ---
== Querying nearest deadline ==
User -> UI: `dashboard` or `nearest`
UI -> CommandParser: parseInput(input)
CommandParser -> Model: getNearestDeadline()
Model -> InternshipList: getAll()
InternshipList --> Model: [Internship@1, Internship@2, ...]
Model -> Internship: getDeadline() ' calls getDeadline on each internship in loop
Internship -> Date: compareTo(dateOther) ' Date handles comparison logic
' Model computes nearest and returns formatted result
CommandParser <-- Model: nearestDeadlineInfo
UI <-- CommandParser: nearestDeadlineInfo
UI --> User: display(nearestDeadlineInfo)

' Notes:
' - `Date` here represents the model class responsible for parsing, storing and comparing deadline values.
' - `Status` is modelled as a small value object or enum wrapper that enforces valid status values.
' - `UI` is the user-facing component responsible for I/O and forwarding raw input to `CommandParser`.
' - `CommandParser` is responsible for parsing raw input into semantic requests (commands) and interacting with `Model`.
' - `Storage` is shown as an abstract persistence component (file or DB). Model / InternshipList calls it after any persistent mutation.
' - All persistence (save) calls are intentional points where data is written to disk; startup load would be the reverse interaction (Storage -> Model -> InternshipList).

@enduml
